\documentclass[plainarticle,zihtitle,german,final,hyperref,utf8]{zihpub}
\usepackage{setspace}
\usepackage{listings}
\author{Bengt Lennicke}
\title{Komplexpraktikum "Paralleles Rechnen" \newline B - Thread-parallele Ausführung von Conways Game-of-Life}

\bibfiles{doku}


\begin{document}

\section{Aufgabenstellung}
Implementieren Sie eine thread-parallele Variante von Conways 'Game-of-Life' mit periodic boundary conditions. Nutzen Sie dazu OpenMP Compiler-Direktiven. Benutzen Sie double buffering um Abhängigkeiten aufzulösen.

\begin{itemize}
	\item Beschreiben Sie Ihren Ansatz und gehen Sie sicher, dass die Arbeit thread-parallel ausgeführt wird.
	\item Messen und Vergleichen Sie die Ausführungszeiten für 1,2,4,8,16 und 32 Threads, für den GCC, als auch den Intel Compiler bei Feldgrößen von 128x128, 512x512, 2048x2048, 8192x8192 und 32768x32768.
	\item Nutzen Sie für die Berechnung eine geeignete Anzahl an Schleifendurchläufen (Zyklen des Spiels), sodass der genutzte Timer genau genug ist.
	\item Nutzen Sie dafür die "romeo" Partition von taurus.
	\item Achten Sie darauf, dass benachbarte Threads möglichst nah einander gescheduled sind.
	\item Testen Sie für die Feldgröße 128x128, welchen Einfluss die OpenMP Schleifenschedulingverfahren haben (OMP\_SCHEDULE), indem Sie für die Ausführung mit 32-Threads des mit Intel kompilierten Benchmarks die Verfahren static, dynamic, guided, und auto bei default chunk size vergleichen
	\item Führen Sie jeweils 20 Messungen durch und analysieren Sie die Ergebnisse mit geeigneten statistischen Mitteln.
\end{itemize}

\subsection{Conways 'Game of Life'}
Conways 'Game of Life' ist ein Gedankenspiel bei dem auf einem zweidimensionalen Spielbrett(board) Felder(cell) 'lebendig' oder 'tot' sind. Im Spielverlauf können die Felder 'lebendig werden', 'sterben', 'am Leben' bzw. 'Tot bleiben'. Das Aktualisieren basiert auf 4 Regeln:\cite{conwaysgame_wiki}
 
\begin{itemize}
	\item Jede lebende Zelle mit weniger als 2 lebendigen Nachbarn stirbt (Unterpopulation)
 	\item Jede lebende Zelle mit 2 oder 3 lebendigen Nachbarn bleibt am Leben
 	\item Jede lebende Zelle mit mehr als 3 lebendigen Nachbarn stirbt (Überpopulation)
 	\item Jede tote Zelle mit genau 3 lebendigen Nachbarn wird lebendig (Reproduktion)
\end{itemize}

 
 Mit diesen einfachen Regeln und wiederholtem Aktualisieren des Boards bildet es ein komplexes System, welches mehrere Interpretionsweisen erlaubt.\cite{conwaysgame_wiki}\newline
 In diesem Bericht ist das Spiel selbst nicht von besonderem Interesse, sondern die Programmiertechnische Umsetzung der Aktualisierung des Boards unter der Verwendung von openMP.
 
\section{Umsetzung}
\subsection{Spielsetup}
Das Spielbrett ist als Struktur in 'gol\_board.h' definiert.
\begin{lstlisting}[language=c, numbers=left]
	#include <stdbool.h>
	typedef struct
	{
		int rows;
		int cols;
		bool grid[0];
	} board;
\end{lstlisting}
Die Felder des Boards werden in einem Array von Bools 'grid' festgehalten. Dieses eindimensionale Array wird dann durch das Festlegen von der Anzahl von Reihen 'rows' und Spalten 'cols' als ein zweidimensionales Brett definiert.\newline
Das 'grid' wird zunächst als leeres Arrays deklariert, relevant ist hier nur, dass es auf ein Array von bools verwiesen wird. Das Allokieren von Speicher für ein Array in gewünschter Boardgröße passiert in 'init\_board()'.
\begin{lstlisting}[language=c, numbers=left]
board* init_board(int rows, int cols, int start_cells) 
{
	board *b = calloc(1, 2*sizeof(int) + (rows * cols) * sizeof(bool));
	b->rows = rows;
	b->cols = cols;
	
	if (start_cells)
	{
		#include <math.h>
		int i;
		for ( i = 0; i < start_cells; i++)
		{
			set_state(b, random_int(0,b->cols),
			random_int(0,b->rows),
			1);
		}
	}
	
	// Glider
	// 001
	// 101
	// 011
	else
	{
		set_state(b, 2, 0, 1);
		set_state(b, 0, 1, 1);
		set_state(b, 2, 1, 1);
		set_state(b, 1, 2, 1);
		set_state(b, 2, 2, 1);
	}
	return b;
}
\end{lstlisting}
Für die Struktur des Boards wird Speicher für die 2 Integer 'rows' und 'cols' sowie für alle Zellen allokiert und mit 0 initalisiert. Dadurch ist für das Setzen einer Startbelegung nur notwendig, dass einige Felder auf 'lebendig' d.h. auf 1 gesetzt werden müssen.\newline
Die Anzahl der gewünschten lebendigen Zellen in der Startbelegung werden an die Funktion übergeben ('start\_cells'). Wenn die Zahl 0 ist, wird ein sogenannter 'Glider' gesetzt. Dieses Objekt bewegt sich Diagonal über das Spielbrett und bietet eine gute Möglichkeit zu testen, ob die Regeln des Spiels korrekt implementiert sind. Wenn 'start\_cells' ungleich 0 ist, wird dementsprechend oft ein zufälliges Feld gewählt, welches auf 1 gesetzt wird. Hierbei ist natürlich möglich, dass eine Zelle zweimal gewählt wird und dementsprechend weniger als 'start\_cells' Zellen lebendig sind. Da für diesen Versuch nur wichtig ist, dass ein Board mit einer Startbelegung existiert, ist das nicht wichtig.\newline
Zum setzen des Status' der Zellen wird in dieser Funktion 'set\_state()' verwendet.
\begin{lstlisting}[language=c, numbers=left]
void set_state (board *b, int x, int y, bool state)
{
	coords_on_board(b, &x, &y);
	b->grid[ y * b->cols + x ] = state;
}
\end{lstlisting}\label{code:set_state}
Zunächst werden die Koordinaten auf das Spielbrett 'zugeschnitten'. In der Aufgabenstellung ist ein Spielbrett mit periodischen Randbedingungen gefordert, d.h. 'coords\_on\_board()' verändert x und y, sollten diese nicht zwischen 0 und 'cols' bzw. 0 und 'rows' liegen, sodass die Koordinaten wirder auf der Brett liegen.\newline
Dadurch ist das Setzen der Zelle darunter nie ein Zugriff außerhalb des belegten Speichers. Es wird in das Array an der Stelle \begin{math}y*\text{b->cols} + x\end{math} geschrieben. Diese Rechnung ergibt sich daraus, dass x für die Spalte und y für die Reihe steht. Im eindimensionalen Arrays muss für einen Zugriff auf z.B. die 3. Reihe wird das Feld nach allen Elementen der ersten beiden Reihen gebraucht. Dementsprechend \begin{math}2*\text{'Anzahl der Elemente pro Reihe'}=2*\text{b->cols}\end{math}.\newline
Für die periodischen Randbedingungen wird in 'coords\_on\_board()' modulo Rechnung verwendet.
\begin{lstlisting}[language=c, numbers=left]
void coords_on_board(board *b, int *x, int *y)
{
	if ( *x < 0 || *x >= b->cols)
	{
		*x = ((*x % b->cols) + b->cols) % b->cols;
	}
	if ( *y < 0 || *y >= b->rows)
	{
		*y = ((*y % b->rows) + b->rows) % b->rows;
	}
}
\end{lstlisting}
Ziel ist hier, dass z.B. x=-1 auf b->cols-1 abgebildet wird, d.h. die Nachbarzellen vom rechten Rand die Zellen ganz Links sind; analog mit Oben und Unten.
Der modulo Operator '\%' in C soll folgende Gleichung erfüllen: \begin{math}a == (a / b) * b + a \% b\end{math}. Das bedeutet es sind auch negative Lösungen möglich. So ist z.B. mit x=-1 und b->cols=300 das Ergebnis \newline\begin{math}a \% b = a - (a/b)*b = -1 - (-1/300) * 300 = -1\end{math},\newline 
weil die '/' Division in hier ganzzahlig teilt.
Diese negative Zahl liegt dann im Interval [-b, b]. Die Zahlen im positiven Bereich werden anschließend durch \begin{math}+b \% b\end{math} nicht verändert. Die Zahlen im negativen Bereich werden dadurch wie gewünscht auf ihr positiven Counterpart abgebildet. 

Der Status in der nächsten Iteration wird über die Funktion 'get\_new\_state()' bestimmt.
\begin{lstlisting}[language=c, numbers=left]
bool get_new_state(board *b, int x, int y)
{
	int neighbours = get_num_neighbours(b, x, y);
	if (check_state(b, x, y))
	{
		if (neighbours < 2) return 0;
		if (neighbours > 3) return 0;
		return 1;
	}
	else
	{
		if ( neighbours == 3 ) return 1;
		return 0;
	}
}
\end{lstlisting}
Mit 'get\_num\_neighbours()' wird die Anzahl der lebendigen Nachbarn der Zelle bestimmt. Anschließend wird über Vergleiche ermittelt, ob der Status der Zelle 1 oder 0 (lebendig oder tot) seien soll.
Für 'tote' Zellen wird nur überprüft, ob es 3 lebendige Nachbarn gibt, ansonsten ändert sich nichts. 'Lebendige' Zellen 'sterben' wenn sie weniger als 2 oder mehr als 3 Nachbarn haben. Hier wird zuerst mit 2 verglichen, da es wahrscheinlicher ist und in dem Fall der Vergleich '>3' gespart wird.\newline

\begin{lstlisting}[language=c, numbers=left]
int get_num_neighbours(board *b , int x, int y)
{
	return
	check_state(b, x-1, y-1) + check_state(b, x, y-1) + check_state(b, x+1, y-1) +
	check_state(b, x-1, y)   +                          check_state(b, x+1, y) +
	check_state(b, x-1, y+1) + check_state(b, x, y+1) + check_state(b, x+1, y+1);
}
\end{lstlisting}
Für die Bestimmung der lebendingen Nachbarn wird von jeder anliegenden Zelle (inkl. diagonal) der Status abgefragt und die Ergebnisse aufaddiert. Die Summe entspricht den lebenden Nachbarn. Die Funktion 'check\_state()' funktioniert genau wie 'set\_state()'.

\subsection{Threaded Brett-Updates}

\section{Ausführung}
\subsection{Hardware}
Die Messung für die Bearbeitung der Aufgaben sind auf dem CPU Cluster Romeo der TU Dresden ausgeführt worden. Dieser Cluster bietet 192 nodes mit jeweils \cite{hpc_compendium}:
\begin{itemize}
	\item 2 x AMD EPYC CPU 7702 (64 cores) @ 2.0 GHz, Multithreading möglich
	\item 512 GB RAM
	\item 200 GB SSD Speicher
	\item Betriebssystem: Rocky Linux 8.7
\end{itemize}

\subsection{Programm-Versionen}
Relevant für die Reproduzierbarkeit sind die Versionen der verwendeten Bibliotheken und Programme.
\begin{itemize}
	\item GNU Make 4.2.1
	\item gcc (GCC) 10.3.0
	\item Python 3.9.5
	\begin{itemize}
		\item numpy 1.24.1
		\item pandas 2.0.0
		\item matplotlib 3.3.4
	\end{itemize}
\end{itemize}

\subsection{Messung}

\section{Auswertung}


\newpage
\begin{thebibliography}{9}
	\bibitem{hpc_compendium}
	HPC Compendium, 'HPC Resources', 12.01.2024\newline
	\url{https://doc.zih.tu-dresden.de/jobs_and_resources/hardware_overview/#romeo}
	
	\bibitem{conwaysgame_wiki}
	Wikipedia Seite, 'Conways Spiel des Lebens', 22.01.2024\newline
	\url{https://de.wikipedia.org/wiki/Conways_Spiel_des_Lebens#Die_Spielregeln}
\end{thebibliography}

\end{document}
