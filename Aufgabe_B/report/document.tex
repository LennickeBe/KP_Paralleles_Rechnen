\documentclass[plainarticle,zihtitle,german,final,hyperref,utf8]{zihpub}
\usepackage{setspace}
\author{Bengt Lennicke}
\title{Komplexpraktikum "Paralleles Rechnen" \newline B - Thread-parallele Ausführung von Conways Game-of-Life}

\bibfiles{doku}


\begin{document}

\section{Aufgabenstellung}
Implementieren Sie eine thread-parallele Variante von Conways 'Game-of-Life' mit periodic boundary conditions. Nutzen Sie dazu OpenMP Compiler-Direktiven. Benutzen Sie double buffering um Abhängigkeiten aufzulösen.

\begin{itemize}
	\item Beschreiben Sie Ihren Ansatz und gehen Sie sicher, dass die Arbeit thread-parallel ausgeführt wird.
	\item Messen und Vergleichen Sie die Ausführungszeiten für 1,2,4,8,16 und 32 Threads, für den GCC, als auch den Intel Compiler bei Feldgrößen von 128x128, 512x512, 2048x2048, 8192x8192 und 32768x32768.
	\item Nutzen Sie für die Berechnung eine geeignete Anzahl an Schleifendurchläufen (Zyklen des Spiels), sodass der genutzte Timer genau genug ist.
	\item Nutzen Sie dafür die "romeo" Partition von taurus.
	\item Achten Sie darauf, dass benachbarte Threads möglichst nah einander gescheduled sind.
	\item Testen Sie für die Feldgröße 128x128, welchen Einfluss die OpenMP Schleifenschedulingverfahren haben (OMP\_SCHEDULE), indem Sie für die Ausführung mit 32-Threads des mit Intel kompilierten Benchmarks die Verfahren static, dynamic, guided, und auto bei default chunk size vergleichen
	\item Führen Sie jeweils 20 Messungen durch und analysieren Sie die Ergebnisse mit geeigneten statistischen Mitteln.
\end{itemize}

\subsection{Conways 'Game of Life'}
Conways 'Game of Life' ist ein Gedankenspiel bei dem auf einem zweidimensionalen Spielbrett(board) Felder(cell) 'lebendig' oder 'tot' sind. Im Spielverlauf können die Felder 'lebendig werden', 'sterben', 'am Leben' bzw. 'Tot bleiben'. Das Aktualisieren basiert auf 4 Regeln:\cite{conwaysgame_wiki}
 
\begin{itemize}
	\item Jede lebende Zelle mit weniger als 2 lebendigen Nachbarn stirbt (Unterpopulation)
 	\item Jede lebende Zelle mit 2 oder 3 lebendigen Nachbarn bleibt am Leben
 	\item Jede lebende Zelle mit mehr als 3 lebendigen Nachbarn stirbt (Überpopulation)
 	\item Jede tote Zelle mit genau 3 lebendigen Nachbarn wird lebendig (Reproduktion)
\end{itemize}

 
 Mit diesen einfachen Regeln und wiederholtem Aktualisieren des Boards bildet es ein komplexes System, welches mehrere Interpretionsweisen erlaubt.\cite{conwaysgame_wiki}\newline
 In diesem Bericht ist das Spiel selbst nicht von besonderem Interesse, sondern die Programmiertechnische Umsetzung der Aktualisierung des Boards unter der Verwendung von openMP.
 
\section{Umsetzung}
\section{Ausführung}
\subsection{Hardware}
Die Messung für die Bearbeitung der Aufgaben sind auf dem CPU Cluster Romeo der TU Dresden ausgeführt worden. Dieser Cluster bietet 192 nodes mit jeweils \cite{hpc_compendium}:
\begin{itemize}
	\item 2 x AMD EPYC CPU 7702 (64 cores) @ 2.0 GHz, Multithreading möglich
	\item 512 GB RAM
	\item 200 GB SSD Speicher
	\item Betriebssystem: Rocky Linux 8.7
\end{itemize}

\subsection{Programm-Versionen}
Relevant für die Reproduzierbarkeit sind die Versionen der verwendeten Bibliotheken und Programme.
\begin{itemize}
	\item GNU Make 4.2.1
	\item gcc (GCC) 10.3.0
\end{itemize}

\subsection{Messung}

\section{Auswertung}


\newpage
\begin{thebibliography}{9}
	\bibitem{hpc_compendium}
	HPC Compendium, 'HPC Resources', 12.01.2024\newline
	\url{https://doc.zih.tu-dresden.de/jobs_and_resources/hardware_overview/#romeo}
	
	\bibitem{conwaysgame_wiki}
	Wikipedia Seite, 'Conways Spiel des Lebens', 22.01.2024\newline
	\url{https://de.wikipedia.org/wiki/Conways_Spiel_des_Lebens#Die_Spielregeln}
\end{thebibliography}

\end{document}
